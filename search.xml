<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[axios中文文档]]></title>
    <url>%2F2019%2F06%2F06%2Fcopy-data%2F</url>
    <content type="text"><![CDATA[原文地址： lewis1990@amoy 基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造)安装 npm安装 1$ npm install axios bower安装 1$ bower install axios 通过cdn引入 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 例子发起一个 GET 请求 123456789101112131415161718192021// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 发起一个 POST 请求 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 同时发起多个请求 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); axios api可以通过导入相关配置发起请求 axios(config)123456789// 发起一个POST请求axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 123456789// 获取远程图片axios(&#123; method:&apos;get&apos;, url:&apos;http://bit.ly/2mTM3nY&apos;, responseType:&apos;stream&apos;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;))&#125;); axios(url[, config])12// 发起一个GET请求（GET是默认的请求方法）axios(&apos;/user/12345&apos;); 请求方法别名为了方便我们为所有支持的请求方法均提供了别名。 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注释当使用以上别名方法时， url ， method 和 data 等属性不用在config重复声明。 同时发生的请求一下两个用来处理同时发生多个请求的辅助函数 axios.all(iterable)axios.spread(callback)创建一个实例你可以创建一个拥有通用配置的axios实例 axios.creat([config])12345var instance = axios.create(&#123; baseURL: &apos;https://some-domain.com/api/&apos;, timeout: 1000, headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;&#125;); 实例的方法以下是所有可用的实例方法，额外声明的配置将与实例配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])请求配置下面是所有可用的请求配置项，只有 url 是必填，默认的请求方法是 GET ，如果没有指定请求方法的话。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; // `url` 是请求的接口地址 url: &apos;/user&apos;, // `method` 是请求的方法 method: &apos;get&apos;, // 默认值 // 如果url不是绝对路径，那么会将baseURL和url拼接作为请求的接口地址 // 用来区分不同环境，建议使用 baseURL: &apos;https://some-domain.com/api/&apos;, // 用于请求之前对请求数据进行操作 // 只用当请求方法为‘PUT’，‘POST’和‘PATCH’时可用 // 最后一个函数需return出相应数据 // 可以修改headers transformRequest: [function (data, headers) &#123; // 可以对data做任何操作 return data; &#125;], // 用于对相应数据进行处理 // 它会通过then或者catch transformResponse: [function (data) &#123; // 可以对data做任何操作 return data; &#125;], // `headers` are custom headers to be sent headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, // URL参数 // 必须是一个纯对象或者 URL参数对象 params: &#123; ID: 12345 &#125;, // 是一个可选的函数负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, // 请求体数据 // 只有当请求方法为&apos;PUT&apos;, &apos;POST&apos;,和&apos;PATCH&apos;时可用 // 当没有设置`transformRequest`时，必须是以下几种格式 // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer data: &#123; firstName: &apos;Fred&apos; &#125;, // 请求超时时间（毫秒） timeout: 1000, // 是否携带cookie信息 withCredentials: false, // default // 统一处理request让测试更加容易 // 返回一个promise并提供一个可用的response // 其实我并不知道这个是干嘛的！！！！ // (see lib/adapters/README.md). adapter: function (config) &#123; /* ... */ &#125;, // `auth` indicates that HTTP Basic auth should be used, and supplies credentials. // This will set an `Authorization` header, overwriting any existing // `Authorization` custom headers you have set using `headers`. auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, // 响应格式 // 可选项 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // 默认值是json // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // 处理上传进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // 处理下载进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // 设置http响应内容的最大长度 maxContentLength: 2000, // 定义可获得的http响应状态码 // return true、设置为null或者undefined，promise将resolved,否则将rejected validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` defines the maximum number of redirects to follow in node.js. // If set to 0, no redirects will be followed. // 最大重定向次数？没用过不清楚 maxRedirects: 5, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos; defines the hostname and port of the proxy server // Use `false` to disable proxies, ignoring environment variables. // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and // supplies credentials. // This will set an `Proxy-Authorization` header, overwriting any existing // `Proxy-Authorization` custom headers you have set using `headers`. // 代理 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // `cancelToken` specifies a cancel token that can be used to cancel the request // (see Cancellation section below for details) // 用于取消请求？又是一个不知道怎么用的配置项 cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应组成response由以下几部分信息组成 1234567891011121314151617181920&#123; // 服务端返回的数据 data: &#123;&#125;, // 服务端返回的状态码 status: 200, // 服务端返回的状态信息 statusText: &apos;OK&apos;, // 响应头 // 所有的响应头名称都是小写 headers: &#123;&#125;, // axios请求配置 config: &#123;&#125;, // 请求 request: &#123;&#125;&#125; 用 then 接收以下响应信息 12345678axios.get(&apos;/user/12345&apos;) .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 默认配置全局修改axios默认配置123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 实例默认配置1234567// 创建实例时修改配置var instance = axios.create(&#123; baseURL: &apos;https://api.example.com&apos;&#125;);// 实例创建之后修改配置instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 配置优先级配置项通过一定的规则合并， request config &gt; instance.defaults &gt; 系统默认 ，优先级高的覆盖优先级低的。 12345678910// 创建一个实例，这时的超时时间为系统默认的 0var instance = axios.create();// 通过instance.defaults重新设置超时时间为2.5s，因为优先级比系统默认高instance.defaults.timeout = 2500;// 通过request config重新设置超时时间为5s，因为优先级比instance.defaults和系统默认都高instance.get(&apos;/longRequest&apos;, &#123; timeout: 5000&#125;); 拦截器你可以在 then 和 catch 之前拦截请求和响应。 1234567891011121314151617// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; // Do something before request is sent return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);// 添加一个响应拦截器axios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); 如果之后想移除拦截器你可以这么做 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你也可以为axios实例添加一个拦截器 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理12345678910111213141516axios.get(&apos;/user/12345&apos;) .catch(function (error) &#123; if (error.response) &#123; // 发送请求后，服务端返回的响应码不是 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 发送请求但是没有响应返回 console.log(error.request); &#125; else &#123; // 其他错误 console.log(&apos;Error&apos;, error.message); &#125; console.log(error.config); &#125;); 你可以用 validateStatus 定义一个http状态码返回的范围. 12345axios.get(&apos;/user/12345&apos;, &#123; validateStatus: function (status) &#123; return status &lt; 500; // Reject only if the status code is greater than or equal to 500 &#125;&#125;) 取消请求你可以通过 cancel token 来取消一个请求 The axios cancel token API is based on the withdrawn cancelable promises proposal. You can create a cancel token using the CancelToken.source factory as shown below: 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // handle error &#125;&#125;);// cancel the request (the message parameter is optional)source.cancel(&apos;Operation canceled by the user.&apos;); You can also create a cancel token by passing an executor function to the CancelToken constructor: 123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // An executor function receives a cancel function as a parameter cancel = c; &#125;)&#125;);// cancel the requestcancel(); Note: you can cancel several requests with the same cancel token. Using application/x-www-form-urlencoded formatBy default, axios serializes JavaScript objects to JSON. To send data in the application/x-www-form-urlencoded format instead, you can use one of the following options. BrowserIn a browser, you can use the URLSearchParams API as follows: 1234var params = new URLSearchParams();params.append(&apos;param1&apos;, &apos;value1&apos;);params.append(&apos;param2&apos;, &apos;value2&apos;);axios.post(&apos;/foo&apos;, params); Note that URLSearchParams is not supported by all browsers (see caniuse.com ), but there is a polyfill available (make sure to polyfill the global environment). Alternatively, you can encode data using the qs library: 12var qs = require(&apos;qs&apos;);axios.post(&apos;/foo&apos;, qs.stringify(&#123; &apos;bar&apos;: 123 &#125;)); Node.jsIn node.js, you can use the querystring module as follows: 12var querystring = require(&apos;querystring&apos;);axios.post(&apos;http://something.com/&apos;, querystring.stringify(&#123; foo: &apos;bar&apos; &#125;)); You can also use the qs library. SemverUntil axios reaches a 1.0 release, breaking changes will be released with a new minor version. For example 0.5.1, and 0.5.4 will have the same API, but 0.6.0 will have breaking changes. Promisesaxios depends on a native ES6 Promise implementation to be supported. If your environment doesn’t support ES6 Promises, you can polyfill. TypeScriptaxios includes TypeScript definitions. 12import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;); Resources Changelog Upgrade Guide Ecosystem Contributing Guide Code of ConductCredits axios is heavily inspired by the $http service provided in Angular. Ultimately axios is an effort to provide a standalone $http -like service for use outside of Angular. LicenseMIT axios中文文档]]></content>
      <categories>
        <category>收藏</category>
      </categories>
  </entry>
</search>
